--- 
# TinyTapeout project information
project:
  wokwi_id:    0        # 0, because we're not using a Wokwi project.

  # If using an HDL, set wokwi_id as 0 and uncomment and list your source files here. 
  # Source files must be in ./src and you must list each source file separately.
  #NOTE: Most sources are from the raybox-zero git submodule, hence the longer paths:
  source_files:
    - top.v
    - raybox-zero/src/rtl/fixed_point_params.v
    - raybox-zero/src/rtl/helpers.v
    - raybox-zero/src/rtl/rbzero.v
    - raybox-zero/src/rtl/spi_registers.v
    - raybox-zero/src/rtl/debug_overlay.v
    - raybox-zero/src/rtl/map_overlay.v
    - raybox-zero/src/rtl/map_rom.v
    - raybox-zero/src/rtl/pov.v
    - raybox-zero/src/rtl/lzc.v
    - raybox-zero/src/rtl/reciprocal.v
    - raybox-zero/src/rtl/wall_tracer.v
    - raybox-zero/src/rtl/row_render.v
    - raybox-zero/src/rtl/vga_mux.v
    - raybox-zero/src/rtl/vga_sync.v
  top_module:  "tt_um_algofoogle_raybox_zero"      # Must start with "tt_um_".

  # How many tiles your design occupies? A single tile is about 167x108 uM.
  tiles: "4x2"
  #NOTE: Version 0.3 of the design technically fits in 2x2 with ~88% utilisation,
  # but it is at risk of various violations, and I want to add more features anyway,
  # so 4x2 is a safer bet.

# Keep a track of the submission yaml
yaml_version: 4

# As everyone will have access to all designs, try to make it easy for someone new to your design to know what
# it does and how to operate it. This info will be automatically collected and used to make a datasheet for the chip.
#
# Here is a great example: https://github.com/davidsiaw/tt02-davidsiaw-stackcalc/blob/38c5647f83aad2aec675d566aa3d67b98f0aac81/info.yaml
documentation: 
  author:       "algofoogle (Anton Maurovic)"
  title:        "raybox-zero"
  language:     "Verilog"
  description:  "Simple VGA ray caster game demo"      # Short description of what your project does

# Longer description of how the project works. You can use standard markdown format.
  how_it_works: |
      NOTE: Doco for this might get updated after the TT04 datasheet is made.
      Check for updates in the README of the tt04-raybox-zero repo
      (https://github.com/algofoogle/tt04-raybox-zero).

      This is a framebuffer-less VGA display generator ('racing the beam') producing a simple
      "3D"-like rendering of a game map using ray casting. It's inspired by Wolf3D and based on
      Lode's popular Raycasting tutorial (https://lodev.org/cgtutor/raycasting.html).

      Think of this as a primitive 'GPU' using a grid map of wall blocks, with basic texture mapping,
      and flat-coloured floor and ceiling. No doors or sprites in this version -- but maybe in TT05?
      In the TT04 130nm process this uses 4x2 tiles (about 0.16 square millimetres) at ~48% utilisation.

      Because no framebuffer is used, rendering/animation can occur at the full frame rate.
      Registers store the 'POV' (Point of View) used for rendering, and these can be set via one
      of the SPI interfaces (`ss_n`, `sclk`, `mosi`). The expectation is that some host controller
      decides what the POV should be (i.e. it implements the game/motion logic), and sends the POV
      via SPI to the chip. An MCU or low-spec CPU should be up to the task, but I've been bit-banging
      SPI with a Raspberry Pi Pico during testing.

      Upon reset, the POV registers are set to display an angled view of the design's small 16x16
      grid map world.

      NOTE: While Wolf3D and most "first person shooters" use a landscape display (i.e. conventional
      desktop monitor orientation), I had to design this to use a portrait orientation (rotated monitor)
      to enable a large number of silicon area optimisations that come from rendering scanline-by-scanline
      instead of column-by-column. If you don't want to turn your monitor on its side, then design
      a game or demo that uses this different perspective. Imagine, for example, Mario's first-person
      view of his 2D platformer world...

      ## Features

      *   640x480 VGA display at ~60Hz from 25MHz clock (25.175MHz ideal)
      *   Portrait "FPS" orientation
      *   RGB222 digital output with HSYNC and VSYNC
      *   Hard-coded 16x16 grid map
      *   3 hard-coded wall textures, with "light-side" and "dark-side" variations
      *   SPI interface to set 'POV'
      *   Debug overlay option for visualising POV register bits
      *   2nd SPI interface ('SPI2') to set floor colour, ceiling colour, or floor 'leak'
      *   'Demo mode' inputs
      *   Registered and unregistered output options
      *   Reset signal loads a meaningful initial POV state
      *   HBLANK and VBLANK outputs that can be used to drive interrupts

      ## Bugs

      TBC

      ## A warning about turning your screen on its side

      As stated, this is designed to drive a display with a *portrait* orientation when
      used as a conventional "first person shooter", but BEWARE: I had the backlights fail on *two* old flat
      panel VGA displays (from circa 2003) not long after turning them on their side. Coincidence? Age?
      A CCFL failure mode? Not sure. I'm using a monitor from 2008 now.

# Instructions on how someone could test your project, include things like what buttons do what and how to set the clock if needed
  how_to_test:  |
      Attach a VGA connector's HSYNC and VSYNC to the chip's respective outputs, with (say) inline 100R resistors
      just for protection. At minimum connect `red[1]`, `green[1]`, and `blue[1]` with inline 270R resistors,
      or better yet use an R2R DAC for each colour output pair. Make sure the VGA GND is also connected, of course.

      Pull up `reg` to select 'registered outputs'. Without this, you will get the unregistered versions, which
      might be murky or have some timing issues -- I included this option for testing purposes.
      In the actual ASIC version of this, I expect the registered outputs will be much cleaner, but we'll see.

      Supply a 25MHz clock (or ideally 25.175MHz), and assert the `reset` signal, and you should get a
      clockwise-90&deg;-rotated display of textured walls with dark grey ceiling (right-hand side)
      and light grey floor (left-hand side).

      Pull up the `debug` input and you should see little squares show up in the corner of the screen that represent
      the current state of the POV registers -- more on this, later.

      Pull up either or both of the `inc_px/py` inputs, and your view should start to drift along slowly.
      This is 'demo mode'. Don't be alarmed when it goes through walls, or for the periods when you see half the
      screen is just grey and the other half is flickering different colours -- this just means you're travelling
      through the middle of a wall block.

# A description of what the inputs do (e.g. red button, SPI CLK, SPI MOSI, etc).
  inputs:
    - 'SPI in: sclk'
    - 'SPI in: mosi'
    - 'SPI in: ss_n'
    - debug
    - inc_px
    - inc_py
    - reg
    - none
# A description of what the outputs do (e.g. status LED, SPI MISO, etc)
  outputs:
    - hsync_n
    - vsync_n
    - red[0]
    - red[1]
    - green[0]
    - green[1]
    - blue[0]
    - blue[1]
# A description of what the bidirectional I/O pins do (e.g. I2C SDA, I2C SCL, etc)
  bidirectional:
    - o_hblank
    - o_vblank
    - 'SPI2 in: reg_sclk'
    - 'SPI2 in: reg_mosi'
    - 'SPI2 in: reg_ss_n'
    - none
    - none
    - none

# The following fields are optional
  tag:          "vga, demo, game, graphics, retro, 3d, spi"
  external_hw:  "VGA connector with RGB222 DAC"      # Describe any external hardware needed
  discord:      "algofoogle"
  doc_link:     "https://github.com/algofoogle/raybox-zero/blob/main/README.md"
  clock_hz:     25000000       # Clock frequency in Hz (if required). 25.175MHz is ideal, but 25.0MHz is fine.
  picture:      "doc/fpga-vs-sim.jpg"
